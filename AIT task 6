# -*- coding: utf-8 -*-
"""ait task 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-WYylFOIaCaKcP8IvMLbv_Y5xoxEfSaJ
"""

class Graph:

    def __init__(self, vertices):
        self.V = vertices
        # Initialize adjacency matrix
        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]

    # A utility function to check if the current color assignment is safe for vertex v
    # Checks if any adjacent vertex (i) has the same color (c)
    def is_safe(self, v, color, c):
        # Iterate through all vertices (i)
        for i in range(self.V):
            # Check if there is an edge (self.graph[v][i] == 1) AND
            # if the neighbor already has the proposed color (color[i] == c)
            if self.graph[v][i] == 1 and color[i] == c:
                return False
        return True

    # A recursive utility function to solve the m-coloring problem using backtracking
    def graph_color_util(self, m, color, v):
        # Base Case: If all vertices have been processed
        if v == self.V:
            return True

        # Try every color from 1 to m
        for c in range(1, m + 1):
            if self.is_safe(v, color, c):
                # 1. Assign color c
                color[v] = c

                # 2. Recur for the next vertex (v + 1)
                if self.graph_color_util(m, color, v + 1):
                    return True

                # 3. Backtrack: If the recursive call fails, unassign the color
                color[v] = 0

        # If no color works for vertex v, return False
        return False

    # Main function to initiate the graph coloring process
    def graph_coloring(self, m):
        # Initialize color array for all vertices (0 means no color assigned)
        color = [0] * self.V

        # Start the recursive utility function from the first vertex (index 0)
        if not self.graph_color_util(m, color, 0):
            print(f"Solution does not exist for m = {m} colors.")
            return False

        # Print the solution if found
        print("Solution exists and following are the assigned colors:")
        # Print the colors assigned to vertices 0 to V-1
        for assigned_color in color:
            print(assigned_color, end=" ")
        print()
        return True

# Driver Code (Execution Block)
if __name__ == '__main__':
    # The graph has 4 vertices, indexed 0, 1, 2, 3 in the code (corresponding to 1, 2, 3, 4 in the image)
    g = Graph(4)

    # Adjacency Matrix (0-indexed: Vertices 0, 1, 2, 3)
    # Edges: (2, 3), (3, 4), (2, 1), (1, 4), (1, 3)
    # Mapping: 1->0, 2->1, 3->2, 4->3
    # Edges: (1, 2), (2, 3), (1, 3), (3, 4), (2, 4)
    # Corrected edges from image: (1,2), (1,3), (1,4), (2,3), (3,4) -- Wait, 5 edges total.
    # Edges: (1,2), (1,3), (1,4), (2,3), (3,4) -> Total 5 edges.

    # Matrix based on the image (V0=1, V1=2, V2=3, V3=4)
    g.graph = [
        # V0 (1) is connected to V1(2), V2(3), V3(4) -> (3 edges)
        [0, 1, 1, 1],
        # V1 (2) is connected to V0(1), V2(3) -> (2 edges)
        [1, 0, 1, 0],
        # V2 (3) is connected to V0(1), V1(2), V3(4) -> (3 edges)
        [1, 1, 0, 1],
        # V3 (4) is connected to V0(1), V2(3) -> (2 edges)
        [1, 0, 1, 0]
    ]

    # Color constraint from the image
    m = 3

    print(f"Graph Coloring for V={g.V} vertices with m={m} colors.")

    # Function call
    g.graph_coloring(m)
